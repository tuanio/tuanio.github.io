<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản" /><meta name="author" content="tuanio" /><meta property="og:locale" content="en" /><meta name="description" content="Nội dung 1. Định nghĩa 2. Ba bài toán nền tảng 3. Bài toán phân tích cảm xúc văn bản 3.1 Giới thiệu bài toán phân tích cảm xúc văn bản 3.2 Bộ dữ liệu Financial News của Kaggle 3.3 Mô hình bài toán 3.4 Phương pháp thực hiện 4. Tổng kết 5. Tham khảo" /><meta property="og:description" content="Nội dung 1. Định nghĩa 2. Ba bài toán nền tảng 3. Bài toán phân tích cảm xúc văn bản 3.1 Giới thiệu bài toán phân tích cảm xúc văn bản 3.2 Bộ dữ liệu Financial News của Kaggle 3.3 Mô hình bài toán 3.4 Phương pháp thực hiện 4. Tổng kết 5. Tham khảo" /><link rel="canonical" href="https://tuanio.github.io//posts/hidden-markov-model-and-sentiment-analysis/" /><meta property="og:url" content="https://tuanio.github.io//posts/hidden-markov-model-and-sentiment-analysis/" /><meta property="og:site_name" content="tuanio" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-03T20:51:00+07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@tuanio" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"tuanio"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tuanio.github.io//posts/hidden-markov-model-and-sentiment-analysis/"},"description":"Nội dung 1. Định nghĩa 2. Ba bài toán nền tảng 3. Bài toán phân tích cảm xúc văn bản 3.1 Giới thiệu bài toán phân tích cảm xúc văn bản 3.2 Bộ dữ liệu Financial News của Kaggle 3.3 Mô hình bài toán 3.4 Phương pháp thực hiện 4. Tổng kết 5. Tham khảo","url":"https://tuanio.github.io//posts/hidden-markov-model-and-sentiment-analysis/","@type":"BlogPosting","headline":"Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản","dateModified":"2022-08-28T19:56:09+07:00","datePublished":"2022-01-03T20:51:00+07:00","@context":"https://schema.org"}</script><title>Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản | tuanio</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="tuanio"><meta name="application-name" content="tuanio"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://deforani.sirv.com/Images/tuanio.github.io/avatar/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">tuanio</a></div><div class="site-subtitle font-italic">Một nơi để viết về những gì tôi đã học</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/tuanio" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.facebook.com/tuanio1211/" aria-label="facebook" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-facebook"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['nvatuan3','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/tuanio" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> tuanio </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Jan 3, 2022, 8:51 PM +0700" >Jan 3<i class="unloaded">2022-01-03T20:51:00+07:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 28, 2022, 7:56 PM +0700" >Aug 28<i class="unloaded">2022-08-28T19:56:09+07:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3611 words">20 min read</span></div></div><div class="post-content"><h3 id="nội-dung">Nội dung</h3><ul><li><a href="#-dinh-nghia">1. Định nghĩa</a><li><a href="#-three-problems">2. Ba bài toán nền tảng</a><li><a href="#-bai-toan-phan-tich-cam-xuc-van-ban">3. Bài toán phân tích cảm xúc văn bản</a><ul><li><a href="#-gioi-thieu-bai-toan">3.1 Giới thiệu bài toán phân tích cảm xúc văn bản</a><li><a href="#-bo-du-lieu">3.2 Bộ dữ liệu Financial News của Kaggle</a><li><a href="#-mo-hinh-bai-toan">3.3 Mô hình bài toán</a><li><a href="#-phuong-phap">3.4 Phương pháp thực hiện</a></ul><li><a href="#-tong-ket">4. Tổng kết</a><li><a href="#-tham-khao">5. Tham khảo</a></ul><p><a name="-dinh-nghia"></a></p><h1 id="1-định-nghĩa">1. Định nghĩa</h1><p>Ở bài viết về <a href="/posts/markov-chain-va-bai-toan-sang-nay-an-gi/">Markov chain</a>, chúng ta đã tìm hiểu về một mô hình được kết hợp bởi các trạng thái, các trạng thái cũng đồng thời cũng là kết quả của mô hình. Trong bài viết này, chúng ta sẽ tìm hiểu về mô hình Markov ẩn (Hidden Markov model - HMM), mà các trạng thái của mô hình lúc này sẽ không phải là thứ chúng ta có thể quan sát được.</p><p>Mô hình Markov ẩn là một mô hình thống kê được kết hợp bởi tập các trạng thái ẩn (hidden state) và tập các quan sát (observation). Mô hình Markov ẩn sử dụng tính chất Markov giống Markov chain, trạng thái hiện tại chỉ phụ thuộc vào trạng thái trước đó, ngoài ra các quan sát hiện tại chỉ phụ thuộc vào trạng thái hiện tại.</p><p>Mô hình Markov ẩn từng thống trị rất nhiều bài toán và lĩnh vực ở thập kỷ trước (chứng cứ là có rất nhiều bài báo được đăng tải liên quan đến mô hình Markov ẩn liên quan đến nhiều lĩnh vực tại thời điểm đó), nhất là trong lĩnh vực <a href="https://en.wikipedia.org/wiki/Speech_recognition" target="_blank">Nhận dạng giọng nói</a> (Speech Recognition). Trong lĩnh vực nhận dạng giọng nói, mô hình Markov ẩn đóng vai trò như một mô hình âm học đại diện cho một đơn vị nhận dạng giọng nói.</p><p>Mô hình Markov ẩn được kết hợp bởi 5 thành phần, ta có thể gọi một mô hình Markov ẩn là $\lambda =(Q, V, A, B, \pi)$ (có thể đơn giản hóa ký hiệu thành $\lambda =(A, B, \pi)$), trong đó:</p><ul><li>$Q=q_1, q_2, \cdots, q_N$ là tập gồm $N$ trạng thái ẩn, $X_t \in Q$ là giá trị ở thời điểm $t$ được lấy trong tập $Q$.<li>$O=o_1, o_2, \cdots, o_T$ là một chuỗi gồm $T$ (là thời điểm cuối cùng) quan sát, mỗi quan sát được lấy từ tập giá trị duy nhất $V = \{v_1, v_2, \cdots, v_V\}$.<li>$A_{N\times N}$ là ma trận xác suất chuyển, được ký hiệu là $A=a_{ij}=\{P(X_{t+1} = q_j|X_t = q_i)|1 \le i,j \le N\}$. Ở đây, $a_{ij}$ đại diện cho xác suất chuyển từ trạng thái $i$ ở thời điểm $t$ sang trạng thái $j$ ở thời điểm $t+1$<li>$B_{V\times N}$ là ma trận xác suất phát xạ (emission probability), và được ký hiệu bởi $B=b_i(k)=\{P(O_t = v_k|X_t=Q_i)|1\le i\le N, 1 \le k \le V\}$. $b_i(k)$ đại diện cho xác suất ký hiệu $v_k$ được phát xạ ra từ trạng thái $i$ tại thời điểm $t$.<li>$\pi=\pi_i=\{P(X_1=S_i)|1\le i \le n\}$ là tập xác suất khởi tạo trạng thái.</ul><p>Hình 2 mô tả trừu tượng cấu trúc của mô hình Markov ẩn được đề cập ở trên. Hình $(a)$ là sơ đồ gồm các tập trạng thái ẩn $q_i$ và các giá trị xác suất chuyển $a_{ij}$, trông giống hệt như một Markov chain. Hình $(b)$ mô tả: với mỗi trạng thái ẩn $q_i$, sẽ có một tập giá trị $v_k$ là tập giá trị sẽ được xuất ra với xác suất $b_i(k)$ tương ứng, và hình $(b)$ là điều khiến mô hình Markov ẩn khác với Markov chain.</p><p> <img data-proofer-ignore data-src="/assets/hmm/hmm_abstract.svg" alt="hmm_abstract" /> <em>Hình 1: Dạng và cấu tạo của mô hình Markov ẩn trừu tượng</em></p><p>Hình dưới đây mô tả một dạng hiện thực của mô hình Markov ẩn, với $X_t \in Q$ và $O_t \in V$. Ta có một dạng của mô hình Markov ẩn theo thời gian thực. Dạng $\cdots$ (ba chấm) ở đây biểu thị các trạng thái trước đó và trạng thái tương lai cách thời điểm $t$ hơn $1$ đơn vị. Theo tính chất Markov, trạng thái hiện tại chỉ phụ thuộc vào trạng thái từ quá khứ cách nó một đơn vị, và trạng thái tương lai cũng chỉ phụ thuộc vào trạng thái hiện tại. Theo công thức toán học có thể mô tả là: \(P(X_t|X_{t-1}, X_{t-2}, X_{t-3}, \cdots)=P(X_t|X_{t-1})\).</p><p> <img data-proofer-ignore data-src="/assets/hmm/hmm_realisation.svg" alt="hmm_realisation" /> <em>Hình 2: Một dạng hiện thực của mô hình Markov ẩn</em></p><p>Do có cấu tạo như hình 2, mô hình Markov ẩn rất thích hợp trong những bài toán mô hình hóa chuỗi các giá trị. Trong thực tế, ta có thể xem các chuỗi giá trị là dữ liệu chúng ta có được từ thực tế và phân phối để lấy ra chuỗi giá trị kia ta không hề biết trước. Trong trường hợp này, ta có thể dùng mô hình Markov ẩn để mô hình hóa chuỗi giá trị đó để có được tập các trạng thái ẩn và phân phối xác suất thích hợp, cách để học và lấy ra các trạng thái ẩn sẽ được trình bày trong phần 2.</p><p>Phần tiếp theo, phần 2 sẽ giới thiệu ba bài toán nền tảng của mô hình Markov ẩn, tuy nền tảng nhưng là nền móng cho mọi bài toán phức tạp hơn trong thế giới thực chiến.</p><p><a name="-three-problems"></a></p><h1 id="2-ba-bài-toán-nền-tảng">2. Ba bài toán nền tảng</h1><p>Ở phần 1, tôi đã đi sơ lược về cấu tạo, cấu trúc và các thành phần đằng sau mô hình Markov ẩn. Đến thời điểm này, chắc hẳn bạn đọc sẽ thắc mắc cách sử dụng mô hình Markov ẩn như thế nào, vì thực tế, mô hình Markov ẩn có một cấu trúc dạng chuỗi tuần tự đặc biệt, trông rất khác so với các mô hình truyền thống như Linear Regression, Logistic Regression, Random Forest, … .</p><p>Vì thế, mô hình Markov ẩn cũng sẽ có những cách sử dụng khác. Cụ thể hơn, để sử dụng mô hình Markov ẩn, ta bắt buộc phải giải quyết được 3 bài toán được mô tả dưới đây. Ba bài toán đó là:</p><ul><li><strong>Bài toán 1</strong>: Đưa trước chuỗi quan sát $O=o_1, o_2, \cdots, o_T$ và mô hình $\lambda = (A, B, \pi)$. Làm cách nào để ta có thể tính hiệu quả $P(O|\lambda)$, chính là xác suất để chuỗi quan sát xảy ra khi biết trước mô hình?<li><strong>Bài toán 2</strong>: Đưa trước chuỗi quan sát $O=o_1, o_2, \cdots, o_T$ và mô hình $\lambda = (A, B, \pi)$. Làm cách nào để ta có thể tìm được một chuỗi trạng thái ẩn $X=X_1, X_2, \cdots, X_T$ để giải thích tốt nhất cho chuỗi quan sát $O$?<li><strong>Bài toán 3</strong>: Làm cách nào để ta có thể điều chỉnh tham số của mô hình $\lambda = (A, B, \pi)$ để tối đa hóa xác suất $P(O|\lambda)$?</ul><p>Bài toán 1 là bài toán đánh giá (evaluation problem), nghĩa là đi tính xác suất xảy ra của một chuỗi quan sát khi ta có được mô hình. Nếu nhìn ở một khía cạnh khác, đây chính là bài toán chấm điểm mô hình, nếu mô hình nào có xác suất $P(O|\lambda)$ cao hơn nghĩa là mô hình đó tốt hơn. Bài toán 2 là bài toán giải mã (decoding problem), có thể hiểu là ta đã có một chuỗi quan sát $O$ và ta có thể thấy, bây giờ ta phải tìm một chuỗi trạng thái ẩn tương ứng (có cùng kích cỡ) $X$ sao cho giải thích tốt nhất chuỗi quan sát $O$ kia. Bài toán 3 là bài toán học (learning problem), là bài toán quan trọng nhất. Vì nhờ bài toán 3, ta có thể tối ưu hóa các tham số của mô hình Markov ẩn $\lambda$ đến mức hội tụ, sử dụng cho nhiều bài toán thực tế khác nhau.</p><p>Cả ba bài toán trên đều có cách giải rất đơn giản, đó là thế vào và thử, tuy nhiên độ phức tạp tính toán sẽ rất cao, nên người ta dùng kỹ thuật quy hoạch động (<a href="https://en.wikipedia.org/wiki/Dynamic_programming" target="_blank">dynamic programming</a>) để tối ưu, giúp giải quyết cả 3 vấn đề một cách quy nạp và theo độ phức tạp đa thức. Cụ thể bài toán 1 có thể giải với thuật toán <a href="https://en.wikipedia.org/wiki/Forward%E2%80%93backward_algorithm" target="_blank">forward-backward</a>, bài toán 2 sẽ giải bằng thuật toán <a href="https://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank">Viterbi</a> và bài toán 3 sẽ giải bằng thuật toán <a href="https://en.wikipedia.org/wiki/Baum%E2%80%93Welch_algorithm" target="_blank">Baum-Welch</a>.</p><p>Trong phần này, tôi chỉ đi giới thiệu về ba bài toán, về cách giải sẽ không được đề cập đến, bạn đọc có hứng thú với lời giải cho ba bài toán có thể tham khảo <a href="#-reference-3">[3]</a>, đây là bài báo rất chất lượng về mô hình Markov ẩn, là nền tảng cho bất cứ ai mới bắt đầu tìm hiểu về mô hình Markov ẩn. Nếu gặp khó khăn trong việc hiện thực thuật toán, bạn đọc có thể tham khảo đến <a href="https://github.com/tuanio/hmm" target="_blank">github</a> của tôi, tôi cũng đã đọc bài báo số <a href="#-reference-3">[3]</a> và hiện thực thành công.</p><p><a name="-bai-toan-phan-tich-cam-xuc-van-ban"></a></p><h1 id="3-bài-toán-phân-tích-cảm-xúc-văn-bản">3. Bài toán phân tích cảm xúc văn bản</h1><p><a name="-gioi-thieu-bai-toan"></a></p><h2 id="31-giới-thiệu-bài-toán-phân-tích-cảm-xúc-văn-bản">3.1 Giới thiệu bài toán phân tích cảm xúc văn bản</h2><p>Phân tích cảm xúc văn bản (<a href="https://en.wikipedia.org/wiki/Sentiment_analysis" target="_blank">sentiment analysis</a>) là bài toán được nghiên cứu trong lĩnh vực Xử lý ngôn ngữ tự nhiên. Mục tiêu của bài toán là tìm ra cảm xúc (<em>tích cực</em>, <em>tiêu cực</em>, <em>trung tính</em>) của một câu chữ trong một lĩnh vực cụ thể nào đó. Bài toán này rất được ưa chuộng trong các công ty mà lượng dữ liệu về chữ của họ lớn, họ có thể khai thác thông tin từ nguồn dữ liệu của họ, từ đó hiểu được khách hàng của họ cần gì. Ví dụ như các bình luận trên shopee hay tiki là một ví dụ, một câu “Tôi rất thích sản phẩm này” sẽ được đánh nhãn là <em>tích cực</em>, câu “Sản phẩm này nhăn nheo quá” sẽ được gán nhãn là <em>tiêu cực</em>, một trường hợp khác có nhãn là <em>trung tính</em>, không rõ ràng <em>tích cực</em> hay <em>tiêu cực</em>, ví dụ như câu “Hôm nay tôi vừa nhận được sản phẩm này”.</p><p>Hiện tại, bài toán này có thể giải quyết bằng những phương pháp Machine Learning hoặc mạnh hơn là Deep Learning, chi tiết bạn đọc có thể tìm hiểu ở <a href="https://paperswithcode.com/task/sentiment-analysis" target="_blank">đây</a>. Nhưng trong phạm vi bài viết này, chúng ta sẽ tiếp cận với một hướng khác, đó là giải quyết bài toán này bằng mô hình Markov ẩn.</p><p><a name="-bo-du-lieu"></a></p><h2 id="32-bộ-dữ-liệu-financial-news-của-kaggle">3.2 Bộ dữ liệu Financial News của Kaggle</h2><p>Bộ dữ liệu chúng ta sẽ đi nghiên cứu là bộ <a href="https://www.kaggle.com/ankurzing/sentiment-analysis-for-financial-news" target="_blank">Financial News</a> được lấy trên Kaggle. Dữ liệu gồm 2 cột, 4837 hàng, cột thứ nhất là nhãn, tức là cảm xúc của văn bản đã được gắn từ trước, gồm 3 giá trị: <code class="language-plaintext highlighter-rouge">positive</code>, <code class="language-plaintext highlighter-rouge">neutral</code>, <code class="language-plaintext highlighter-rouge">negative</code>. Cột thứ hai là văn bản. Dữ liệu này đầy đủ và đơn giản để sử dụng trong bài toán này.</p><p><a name="-mo-hinh-bai-toan"></a></p><h2 id="33-mô-hình-bài-toán">3.3 Mô hình bài toán</h2><p>Khi ứng dụng mô hình Markov ẩn vào bài toán phân lớp (classification) như chúng ta đang định làm, chúng ta phải mô hình hóa một số lượng mô hình Markov ẩn riêng biệt bằng với số lượng lớp của bài toán. Nếu lấy bộ dữ liệu Financial News kia làm chuẩn, ta sẽ có 3 mô hình Markov ẩn tương ứng với 3 lớp <code class="language-plaintext highlighter-rouge">positive</code>, <code class="language-plaintext highlighter-rouge">neutral</code> và <code class="language-plaintext highlighter-rouge">negative</code>.</p><p>Mô hình Markov ẩn sẽ làm tốt công việc của mình trong việc mô hình hóa phân phối xác suất của riêng từng lớp. Nếu coi tập dữ liệu là $O$ và có tổng cộng 3 mô hình Markov ẩn tương ứng với 3 lớp thì lớp dự đoán khi ta đưa dữ liệu mới vào sẽ theo công thức dưới đây:</p>\[C^\star = \underset{C}{\mathrm{argmax }} P(O|\lambda_C)\]<p>Trong đó:</p><ul><li>$C$ là lớp (nhãn) và $C^\star$ là lớp dự đoán.<li>$\lambda_C$ là mô hình Markov ẩn tương ứng với mỗi lớp.<li>$P(O|\lambda_C)$ chính là bài toán 1, bài toán đánh giá mô hình.</ul><p>Bất cứ mô hình Machine Learning nào cũng sẽ có giai đoạn huấn luyện, mô hình Markov ẩn cũng không ngoại lệ. Hình (3a) mô tả quy trình này, ban đầu ta có một tập dữ liệu $O$ (có thể là nhiều $O$) và $n$ lớp (nhãn) tương ứng. Ta sẽ chia tập dữ liệu ra thành $n$ tập dữ liệu nhỏ hơn tương ứng với $n$ nhãn. Sau đó dùng thuật toán Baum-Welch (bài toán số 3) để huấn luyện cho mô hình $\lambda_{C_i}$ tương ứng. Kết thúc quá trình huấn luyện, ta được $n$ mô hình Markov ẩn tương ứng với $n$ nhãn lớp.</p><p>Để có thể sử dụng $n$ mô hình kia trong quá trình kiểm thử hoặc đi dự đoán. Ta cần đưa dữ liệu kiểm thử cho cả $n$ mô hình Markov ẩn, sau đó đi tìm các xác suất $P(O|\lambda_{C_i})$ (bài toán số 1) và chọn nhãn $C$ có giá trị xác suất lớn nhất, nhãn $C$ này sẽ là nhãn dự đoán cho chuỗi quan sát $O$ ta đưa vào. Hình (3b) mô tả rõ quy trình này.</p><p> <img data-proofer-ignore data-src="/assets/hmm/hmm_diagram.svg" alt="hmm_diagram" /> <em>Hình 3: Sơ đồ của mô hình Markov ẩn (a) trong quá trình huấn luyện và (b) trong quá trình kiểm thử</em></p><p><a name="-phuong-phap"></a></p><h2 id="34-phương-pháp-thực-hiện">3.4 Phương pháp thực hiện</h2><p>Bây giờ chúng ta sẽ đi đến phần hiện thực bài toán, tôi sẽ sử dụng ngôn ngữ lập trình Python với các thư viện ở ô code dưới đây.</p><p>⚠️ <strong>Lưu ý</strong>: khi code báo lỗi thư viện, các bạn có thể tự cài thư viện thông qua <code class="language-plaintext highlighter-rouge">pip install {tên thư viện}</code>.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span> <span class="c1"># thư viện tính toán 
</span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span> <span class="c1"># đọc file csv
</span><span class="kn">import</span> <span class="nn">concurrent.futures</span> <span class="k">as</span> <span class="n">cf</span> <span class="c1"># thư viện giúp code python chạy đa luồng
</span><span class="kn">from</span> <span class="nn">hmmlearn</span> <span class="kn">import</span> <span class="n">hmm</span> <span class="c1"># thư viện mô hình Markov ẩn 
</span><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span> <span class="c1"># lượng hóa vector
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span> <span class="c1"># đo độ chính xác của mô hình
</span><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">TruncatedSVD</span> <span class="c1"># giảm chiều dữ liệu
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span> <span class="c1"># chia tập dữ liệu train|test
</span><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfVectorizer</span> <span class="c1"># tạo feature cho mô hình từ chữ
</span></pre></table></code></div></div><p>👉 Chúng ta sẽ đi qua các bước như sau:</p><ol><li>Tạo feature dữ liệu số từ dữ liệu chữ có sẵn bằng TF-IDF.<li>Lượng hóa vector (vector quantization) dữ liệu số liên tục thành dạng định tính có thể đem đi huấn luyện.<li>Chia tập dữ liệu huấn luyện, kiểm thử tương ứng.<li>Huấn luyện bộ mô hình Markov ẩn với tập dữ liệu huấn luyện.<li>Đánh giá mô hình Markov ẩn thông qua tập dữ liệu kiểm thử.</ol><p>Trước tiên, ta sẽ đọc dữ liệu để có thể chuẩn bị cho bước tạo feature cho mô hình. Dữ liệu đã được đề cập trong phần 3.2.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'all-data.csv'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"ISO-8859-1"</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">'label'</span><span class="p">,</span> <span class="s">'text'</span><span class="p">])</span>
</pre></table></code></div></div><p>Để trạng thái của code không thay đổi qua mỗi lần chạy, ta nên gán cụ thể giá trị <code class="language-plaintext highlighter-rouge">random state</code> cho các thư viện. Dưới đây tôi định nghĩa biến <code class="language-plaintext highlighter-rouge">rs</code> là giá trị <code class="language-plaintext highlighter-rouge">random state</code> để dùng cho các code sau. Giá trị các bạn có thể thay đổi bất kỳ.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">rs</span> <span class="o">=</span> <span class="mi">8</span>
</pre></table></code></div></div><p>Tạo biến <code class="language-plaintext highlighter-rouge">corpus</code> để gán dữ liệu chữ vào, tiện sử dụng về sau.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">corpus</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'text'</span><span class="p">].</span><span class="n">values</span>
</pre></table></code></div></div><p>Như các mô hình Machine Learning truyền thống khác, mô hình Markov ẩn sẽ chỉ làm việc được với các giá trị số. Mà dữ liệu ban đầu của chúng ta là dữ liệu dạng chữ, nên ta phải chuyển từ chữ sang số. Để làm như vậy, ta sử dụng TF-IDF để tính toán các giá trị trọng số để đại diện cho từng từ một trong bộ ngữ liệu ban đầu. Chi tiết hơn về TF-IDF, bạn đọc có thể tham khảo ở <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank">đây</a>. Còn trong Python, ta sẽ tính bằng đoạn code sau:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">tfidf</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">(</span><span class="n">stop_words</span><span class="o">=</span><span class="s">'english'</span><span class="p">)</span>
<span class="n">transformed</span> <span class="o">=</span> <span class="n">tfidf</span><span class="p">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Kích cỡ dữ liệu:"</span><span class="p">,</span> <span class="n">transformed</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
</pre></table></code></div></div><pre><code class="language-plain">Kích cỡ dữ liệu: (4846, 9820)
</code></pre><p>Như bạn đọc cũng đã thấy, có tận 9820 cột dữ liệu được tạo ra, như vậy là quá nhiều, ta phải dùng cách nào đó để giữ lại các thông tin quan trọng nhất, giảm bớt số lượng cột lại, nhờ đó giúp giảm thời gian huấn luyện và kiểm thử, mô hình cũng không phải học những thông tin dư thừa. Trong trường hợp này, ta sẽ dùng <code class="language-plaintext highlighter-rouge">Truncated SVD</code> với số lượng cột ta muốn giữ lại là 300. Chi tiết về <code class="language-plaintext highlighter-rouge">Truncated SVD</code>, bạn đọc có thể tham khảo ở <a href="https://machinelearningcoban.com/2017/06/07/svd/#-truncated-svd" target="_blank">blog machine learning cơ bản</a>.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">svd</span> <span class="o">=</span> <span class="n">TruncatedSVD</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rs</span><span class="p">)</span>
<span class="n">X_transformed</span> <span class="o">=</span> <span class="n">svd</span><span class="p">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">transformed</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Kích cỡ dữ liệu:"</span><span class="p">,</span> <span class="n">X_transformed</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">X_transformed</span><span class="p">)</span>
</pre></table></code></div></div><pre><code class="language-plain">Kích cỡ dữ liệu: (4846, 300)
[[ 2.74853772e-02  1.23546023e-01 -9.18267054e-02 ... -1.04585446e-02
   6.31456379e-02  1.64352977e-02]
 [ 1.71779475e-02  6.60849287e-02 -3.16730100e-02 ...  3.16069539e-02
   2.32036018e-02 -8.03645790e-03]
 [ 2.53099565e-02  8.71819162e-02 -5.00550792e-02 ... -5.08493999e-02
  -6.52592321e-02 -4.16690704e-02]
 ...
 [ 6.29146372e-01 -1.92710754e-01  3.24730118e-02 ...  3.28086253e-02
  -1.07719957e-02 -8.53337727e-04]
 [ 6.66497950e-01 -1.41546038e-01  1.81541966e-03 ...  7.96125651e-03
  -2.97791037e-03 -1.60182069e-04]
 [ 9.54134895e-02  1.71111951e-01 -6.08651229e-02 ... -1.30032385e-02
   3.79181183e-02  1.24508153e-02]]
</code></pre><p>Ngoài vấn đề có quá nhiều cột trong feature đã được giải quyết, ta còn gặp thêm một vấn đề nữa đó là dữ liệu không phù hợp với mô hình Markov ẩn. Như đã tìm hiểu trên phần 1, các quan sát $O$ của mô hình Markov ẩn được lấy từ một tập $V$ phần tử, vì thế, dữ liệu đưa vào cho mô hình Markov ẩn phải là dạng định tính.</p><p>Để giải quyết vấn đề trên, ta có thể dùng một kỹ thuật được gọi là lượng hóa vector (<a href="https://en.wikipedia.org/wiki/Vector_quantization" target="_blank">vector quantization</a>). Lượng hóa vector có thể hiểu đơn giản là phân cụm các giá trị liên tục thành một tập các cụm có sự giống nhau. Chỉ số của các cụm bây giờ có thể coi như là các giá trị được lấy trong tập $V = \text{số cụm}$ phần tử. Giá trị trong cùng một tập sẽ có cùng một chỉ số này. Ở phần hiện thực, tôi sẽ đi lượng hóa vector bằng thuật toán <a href="https://en.wikipedia.org/wiki/K-means_clustering" target="_blank">K-Means</a> với số cụm là 30.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">X_cluster</span> <span class="o">=</span> <span class="n">X_transformed</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 

<span class="n">vq</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span> <span class="c1"># vector quantization
</span><span class="n">vq</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_cluster</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">map_vq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">vq</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">with</span> <span class="n">cf</span><span class="p">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">exe</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">exe</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">map_vq</span><span class="p">,</span> <span class="n">X_transformed</span><span class="p">)))</span>

<span class="k">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></table></code></div></div><pre><code class="language-plain">[[ 9 11  0 ...  8 16 22]
 [27 16 20 ...  9 27  8]
 [ 9  3 19 ... 19 28 10]
 ...
 [26 24  4 ...  4  8 13]
 [26 24 13 ...  1 29 13]
 [ 3 18 28 ... 17  4 22]]
</code></pre><p>Như bạn có thể thấy, dữ liệu định lượng được lấy ra từ TF-IDF đã chuyển thành dạng số nguyên, là chỉ số của các cụm. Bây giờ, ta sẽ đi phân chia dữ liệu thành hai tập: huấn luyện và kiểm thử với tỉ lệ 8:2.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'label'</span><span class="p">]</span>

<span class="n">Xtrain</span><span class="p">,</span> <span class="n">Xtest</span><span class="p">,</span> <span class="n">ytrain</span><span class="p">,</span> <span class="n">ytest</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rs</span><span class="p">)</span>
</pre></table></code></div></div><p>Sau khi đã có dữ liệu, ta sẽ đi tạo mô hình Markov ẩn cho bài toán này rồi mới huấn luyện. Ta sẽ tạo cấu trúc mô hình giống như hình 3.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">HMMSystem</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rs</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
    
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">hmm_models</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">cf</span><span class="p">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">exe</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">hmm_models</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exe</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_create_model</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">labels</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">hmm_models</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">hmm_models</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>
        
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">cf</span><span class="p">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">exe</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">exe</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_find_class</span><span class="p">,</span> <span class="n">X</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">pred</span>
    
    <span class="k">def</span> <span class="nf">_create_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">hmm</span><span class="p">.</span><span class="n">MultinomialHMM</span><span class="p">(</span>
            <span class="n">n_components</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">n_components</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">random_state</span>
        <span class="p">).</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">label</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">model</span>
    
    <span class="k">def</span> <span class="nf">_find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_decode</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">model</span><span class="p">.</span><span class="n">decode</span><span class="p">([</span><span class="n">data</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">with</span> <span class="n">cf</span><span class="p">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">exe</span><span class="p">:</span>
            <span class="n">logprobs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exe</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">_decode</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">hmm_models</span><span class="p">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">labels</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logprobs</span><span class="p">)]</span>
</pre></table></code></div></div><p>Huấn luyện mô hình với tập dữ liệu huấn luyện. Ta sẽ chọn số lượng trạng thái ẩn $Q$ là 8.</p><p>⚠️ <strong>Lưu ý:</strong> quá trình huấn luyện có thể hơi lâu, khoảng vài phút.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">model</span> <span class="o">=</span> <span class="n">HMMSystem</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span>
<span class="n">model</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></table></code></div></div><p>Dùng tập kiểm thử để dự đoán với mô hình đã huấn luyện.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">ytest_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xtest</span><span class="p">)</span>
<span class="n">ytrain_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xtrain</span><span class="p">)</span>
</pre></table></code></div></div><p>Cuối cùng là đi đánh giá trên cả hai tập dữ liệu đã dự đoán.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">acc_train</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">ytrain</span><span class="p">,</span> <span class="n">ytrain_pred</span><span class="p">)</span>
<span class="n">acc_test</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">ytest</span><span class="p">,</span> <span class="n">ytest_pred</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Độ chính xác tập huấn luyện: %.2f/1"</span> <span class="o">%</span> <span class="n">acc_train</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Độ chính xác tập kiểm thử: %.2f/1"</span> <span class="o">%</span> <span class="n">acc_test</span><span class="p">)</span>
</pre></table></code></div></div><pre><code class="language-plain">Độ chính xác tập huấn luyện: 0.46/1
Độ chính xác tập kiểm thử: 0.48/1
</code></pre><p>Độ chính xác của mô hình là $48\%$ trên tập kiểm thử, mức độ chính xác này vào khoảng giữa, 50:50, nên kết quả dự đoán của mô hình còn khá rủi ro.</p><p>Toàn bộ code Python hiện thực sẽ để ở <a href="https://github.com/tuanio/sentiment-analysis-discrete-hmm" target="_blank">đây</a>.</p><p><a name="-tong-ket"></a></p><h1 id="4-tổng-kết">4. Tổng kết</h1><p>Trong bài viết này, chúng ta đã đi qua sơ lược về định nghĩa, các thành phần và các bài toán của mô hình Markov ẩn. Từ đó ứng dụng mô hình Markov ẩn vào bài toán phân tích cảm xúc văn bản. Độ chính xác của mô hình không quá cao, nhưng nó giúp bạn đọc có thể hiểu thêm về mô hình này. Bạn đọc có thể đọc thêm về mô hình Markov ẩn ở các bài báo và địa chỉ website trong phần 5.</p><p><a name="-tham-khao"></a></p><h1 id="5-tham-khảo">5. Tham khảo</h1><p>[1] https://web.stanford.edu/~jurafsky/slp3/A.pdf</p><p>[2] https://en.wikipedia.org/wiki/Hidden_Markov_model</p><p>[3] A Tutorial on Hidden Markov Models and Selected Applications in Speech Recognition. Rabiner. 1989. <a name="-reference-3"></a></p><p>[4] A Systematic Review of Hidden Markov Models and Their Applications. Bhavya Mor, Sunita Garhwal &amp; Ajay Kumar. 2021.</p><p>[5] Hidden Markov Models for Sentiment Analysis in Social Medias. Isidoros Perikos. 2019.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/knowledge/'>knowledge</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/machine-learning/" class="post-tag no-text-decoration" >machine learning</a> <a href="/tags/probability/" class="post-tag no-text-decoration" >probability</a> <a href="/tags/nlp/" class="post-tag no-text-decoration" >nlp</a> <a href="/tags/sentiment-analysis/" class="post-tag no-text-decoration" >sentiment analysis</a> <a href="/tags/hmm/" class="post-tag no-text-decoration" >hmm</a> <a href="/tags/markov-process/" class="post-tag no-text-decoration" >markov process</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản - tuanio&url=https://tuanio.github.io//posts/hidden-markov-model-and-sentiment-analysis/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản - tuanio&u=https://tuanio.github.io//posts/hidden-markov-model-and-sentiment-analysis/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản - tuanio&url=https://tuanio.github.io//posts/hidden-markov-model-and-sentiment-analysis/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/autorec/">AutoRec: Autoencoder dành cho Collaborative Filtering</a><li><a href="/posts/source-nlp/">Nguồn tài liệu để học NLP</a><li><a href="/posts/markov-chain-va-bai-toan-sang-nay-an-gi/">Markov Chain và bài toán 'Sáng nay ăn gì'</a><li><a href="/posts/minh-da-hoc-duoc-ghi-trong-nam-nay/">Mình đã học được gì trong năm nay?</a><li><a href="/posts/hidden-markov-model-and-sentiment-analysis/">Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/machine-learning/">machine learning</a> <a class="post-tag" href="/tags/autoencoder/">autoencoder</a> <a class="post-tag" href="/tags/feedforward-neural-network/">feedforward neural network</a> <a class="post-tag" href="/tags/markov-process/">markov process</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/probability/">probability</a> <a class="post-tag" href="/tags/supervised-learning/">supervised learning</a> <a class="post-tag" href="/tags/alexnet/">alexnet</a> <a class="post-tag" href="/tags/anomaly-detection/">anomaly detection</a> <a class="post-tag" href="/tags/audio-classification/">audio classification</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/markov-chain-va-bai-toan-sang-nay-an-gi/"><div class="card-body"> <span class="timeago small" >Dec 26, 2021<i class="unloaded">2021-12-26T21:35:00+07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Markov Chain và bài toán 'Sáng nay ăn gì'</h3><div class="text-muted small"><p> Nội dung 1. Định nghĩa Markov chain 2. Bài toán “sáng nay ăn gì” 3. Tổng kết Trong bài viết này, chúng ta sẽ đi qua sơ lược về định nghĩa của Markov chain, từ đó hiểu thêm về Markov chain ...</p></div></div></a></div><div class="card"> <a href="/posts/source-nlp/"><div class="card-body"> <span class="timeago small" >Dec 23, 2021<i class="unloaded">2021-12-23T15:11:00+07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Nguồn tài liệu để học NLP</h3><div class="text-muted small"><p> Bài viết này mang tính chất lưu trữ và chia sẻ. Những nguồn khi mới bắt đầu How to get started in nlp - medium Dữ liệu nlp-datasets - github Sách Deep Learning for NLP and Speech R...</p></div></div></a></div><div class="card"> <a href="/posts/elm/"><div class="card-body"> <span class="timeago small" >Jan 10<i class="unloaded">2022-01-10T21:07:00+07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Extreme Learning Machine: Thuật toán học nhanh cho mạng neuron truyền thẳng một lớp ẩn</h3><div class="text-muted small"><p> Nội dung 1. Mạng neuron truyền thẳng một lớp ẩn 1.1 Định nghĩa 1.2 Bài toán học tham số 2. Thuật toán Extreme Learning Machine 3. Thực nghiệm thuật toán Extreme Lear...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/minh-da-hoc-duoc-ghi-trong-nam-nay/" class="btn btn-outline-primary" prompt="Older"><p>Mình đã học được gì trong năm nay?</p></a> <a href="/posts/elm/" class="btn btn-outline-primary" prompt="Newer"><p>Extreme Learning Machine: Thuật toán học nhanh cho mạng neuron truyền thẳng một lớp ẩn</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/tuanio">Nguyễn Văn Anh Tuấn</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/machine-learning/">machine learning</a> <a class="post-tag" href="/tags/autoencoder/">autoencoder</a> <a class="post-tag" href="/tags/feedforward-neural-network/">feedforward neural network</a> <a class="post-tag" href="/tags/markov-process/">markov process</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/probability/">probability</a> <a class="post-tag" href="/tags/supervised-learning/">supervised learning</a> <a class="post-tag" href="/tags/alexnet/">alexnet</a> <a class="post-tag" href="/tags/anomaly-detection/">anomaly detection</a> <a class="post-tag" href="/tags/audio-classification/">audio classification</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-ZJYTV5L278"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-ZJYTV5L278'); }); </script>
