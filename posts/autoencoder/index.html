<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Autoencoder và bài toán phát hiện bất thường trong an ninh mạng" /><meta name="author" content="tuanio" /><meta property="og:locale" content="en" /><meta name="description" content="Nội dung 1. Giới thiệu Autoencoder 2. Bài toán phát hiện bất thường trong an ninh mạng 3. Thực nghiệm Autoencoder với bộ dữ liệu NSL-KDD 3.1 Giới thiệu bộ dữ liệu NSL-KDD 3.2 Hiện thực 4. Tổng kết 5. Tham khảo" /><meta property="og:description" content="Nội dung 1. Giới thiệu Autoencoder 2. Bài toán phát hiện bất thường trong an ninh mạng 3. Thực nghiệm Autoencoder với bộ dữ liệu NSL-KDD 3.1 Giới thiệu bộ dữ liệu NSL-KDD 3.2 Hiện thực 4. Tổng kết 5. Tham khảo" /><link rel="canonical" href="https://tuanio.github.io//posts/autoencoder/" /><meta property="og:url" content="https://tuanio.github.io//posts/autoencoder/" /><meta property="og:site_name" content="tuanio" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-16T15:33:00+07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Autoencoder và bài toán phát hiện bất thường trong an ninh mạng" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@tuanio" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"tuanio"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tuanio.github.io//posts/autoencoder/"},"description":"Nội dung 1. Giới thiệu Autoencoder 2. Bài toán phát hiện bất thường trong an ninh mạng 3. Thực nghiệm Autoencoder với bộ dữ liệu NSL-KDD 3.1 Giới thiệu bộ dữ liệu NSL-KDD 3.2 Hiện thực 4. Tổng kết 5. Tham khảo","url":"https://tuanio.github.io//posts/autoencoder/","@type":"BlogPosting","headline":"Autoencoder và bài toán phát hiện bất thường trong an ninh mạng","dateModified":"2022-08-28T19:56:09+07:00","datePublished":"2022-01-16T15:33:00+07:00","@context":"https://schema.org"}</script><title>Autoencoder và bài toán phát hiện bất thường trong an ninh mạng | tuanio</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="tuanio"><meta name="application-name" content="tuanio"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://deforani.sirv.com/Images/tuanio.github.io/avatar/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">tuanio</a></div><div class="site-subtitle font-italic">Một nơi để viết về những gì tôi đã học</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/tuanio" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.facebook.com/tuanio1211/" aria-label="facebook" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-facebook"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['nvatuan3','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/tuanio" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Autoencoder và bài toán phát hiện bất thường trong an ninh mạng</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Autoencoder và bài toán phát hiện bất thường trong an ninh mạng</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> tuanio </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Jan 16, 2022, 3:33 PM +0700" >Jan 16<i class="unloaded">2022-01-16T15:33:00+07:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 28, 2022, 7:56 PM +0700" >Aug 28<i class="unloaded">2022-08-28T19:56:09+07:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2357 words">13 min read</span></div></div><div class="post-content"><h3 id="nội-dung">Nội dung</h3><ul><li><a href="#-gioi-thieu-autoencoder">1. Giới thiệu Autoencoder</a><li><a href="#-bai-toan">2. Bài toán phát hiện bất thường trong an ninh mạng</a><li><a href="#-thuc-nghiem">3. Thực nghiệm Autoencoder với bộ dữ liệu NSL-KDD</a><ul><li><a href="#-gioi-thieu-du-lieu">3.1 Giới thiệu bộ dữ liệu NSL-KDD</a><li><a href="#-hien-thuc">3.2 Hiện thực</a></ul><li><a href="#-tong-ket">4. Tổng kết</a><li><a href="#-tham-khao">5. Tham khảo</a></ul><p><a name="-gioi-thieu-autoencoder"></a></p><h1 id="1-giới-thiệu-autoencoder">1. Giới thiệu Autoencoder</h1><p>Autoencoder là một mạng neuron truyền thẳng học không giám sát (unsupervised feedforward neural network). Mục đích của Autoencoder là cố gắng tái tạo dữ liệu đầu vào sao cho giống nhất có thể. Autoencoder thường được dùng trong các bài toán giảm chiều dữ liệu, khử nhiễu từ ảnh hoặc phát hiện bất thường, trong bài viết này, chúng ta sẽ tập trung vào bài toán phát hiện bất thường.</p><p> <img data-proofer-ignore data-src="/assets/autoencoder/basic_ae.svg" alt="basic_ae" /> <em>Hình 1: Cấu trúc cơ bản của Autoencoder</em></p><p>Một mạng Autoencoder có thể chia thành 3 thành phần chính: encoder $f(x)$, code $h$ và decoder $g(h)$. Cụ thể thì mạng sẽ trông như hình 1. Lớp code còn được gọi là lớp đại diện, thường thì sẽ có kích cỡ nhỏ nhất trong mạng, tác dụng chính của lớp này dùng để lưu trữ những thông tin quan trọng nhất từ dữ liệu đầu vào. Trong khi đó, lớp encoder cố gắng đưa dữ liệu đầu vào thành lớp code, còn lớp decoder cố gắng tái tạo lại dữ liệu đầu ra từ lớp code. Nếu coi $x$ là dữ liệu đầu vào, $r$ là dữ liệu tái tạo từ lớp decoder, ta có thể hiểu là: $h=f(x)$, $r=g(h)$. Autoencoder thực chất cũng là mạng neuron, nên có thể huấn luyện thông qua back-propagation với hàm lỗi là $L(x, r)$, thường thì hàm lỗi sẽ là Mean Square Error.</p><p>Cấu trúc của encoder, code và decoder trong mỗi dạng, bài toán sử dụng Autoencoder sẽ khác nhau. Một mạng Autoencoder đơn giản sẽ chỉ có 3 lớp ẩn, tương ứng với 3 lớp encoder, code và decoder, trong đó encoder và decoder có kích cỡ giống nhau, code sẽ có kích cỡ nhỏ. Còn một mạng Deep Autoencoder sẽ xếp chồng nhiều lớp ẩn lại và thu nhỏ kích cỡ lần lượt trong encoder, decoder sẽ là phiên bản ngược lại của encoder. Hình 2 mô tả cấu trúc của mạng Deep Autoencoder. Deep Autoencoder đặc biệt thích hợp trong bài toán phát hiện bất thường.</p><p> <img data-proofer-ignore data-src="/assets/autoencoder/deep_ae.png" alt="deep_ae" /> <em>Hình 2: Cấu trúc của Deep Autoencoder</em></p><p><a name="-bai-toan"></a></p><h1 id="2-bài-toán-phát-hiện-bất-thường-trong-an-ninh-mạng">2. Bài toán phát hiện bất thường trong an ninh mạng</h1><p>Bất thường, tiếng anh là anomaly, outliers là những dữ liệu trông có vẻ khác xa so với đa số dữ liệu chúng ta có. Có thể là một điểm có giá trị rất lớn trong tập dữ liệu mà đa phần chỉ toàn giá trị nhỏ.</p><p>Trong lĩnh vực an ninh mạng, dữ liệu sẽ là những thông tin trong mạng, như thời gian gửi gói tin, độ trễ, thời gian chờ,… . Đa phần người sử dụng mạng trong một mạng lưới là người dùng bình thường, không có mục đích tấn công vào một trụ sở, nên dữ liệu của mỗi người sẽ tương đối giống nhau. Nhưng đối với những người dùng có ý đồ xấu, gọi là hacker, dữ liệu mạng này sẽ khác so với dữ liệu của một người dùng bình thường, nguyên nhân là các hacker sẽ dùng các phương pháp tấn công đặc biệt, mà trong quá trình thao tác, dữ liệu mạng sẽ bị biến đổi theo cách khác. Ta có thể dựa vào đó để phát hiện xâm nhập trong an ninh mạng.</p><p>Mục đích của Autoencoder sẽ là cố gắng tái tạo dữ liệu đầu vào sao cho giống nhất với dữ liệu huấn luyện. Dựa vào thông tin này, ta có thể chỉ đưa dữ liệu thuộc lớp <code class="language-plaintext highlighter-rouge">normal</code> là dữ liệu bình thường, không phải bất thường cho Autoencoder học. Sau đó ta sẽ đi tính lỗi tái tạo (reconstruction error) trên cả tập dữ liệu <code class="language-plaintext highlighter-rouge">normal</code> lẫn <code class="language-plaintext highlighter-rouge">abnormal</code>, nếu độ lỗi tái tạo càng nhỏ, có nghĩa là việc Autoencoder tái tạo tập <code class="language-plaintext highlighter-rouge">normal</code> là đúng, ngược lại, độ lỗi tái tạo cao, nghĩa là dữ liệu đầu vào khác so với <code class="language-plaintext highlighter-rouge">normal</code>, nghĩa là <code class="language-plaintext highlighter-rouge">abnormal</code>, lúc này độ lỗi tái tạo giống như một histogram, ta chỉ cần tìm một ngưỡng để phân tách hai tập lỗi của <code class="language-plaintext highlighter-rouge">normal</code> và <code class="language-plaintext highlighter-rouge">abnormal</code>. Bài toán lúc này trở thành bài toán phân loại nhị phân (binary classification).</p><p><a name="-thuc-nghiem"></a></p><h1 id="3-thực-nghiệm-autoencoder-với-bộ-dữ-liệu-nsl-kdd">3. Thực nghiệm Autoencoder với bộ dữ liệu NSL-KDD</h1><p><a name="-gioi-thieu-du-lieu"></a></p><h2 id="31-giới-thiệu-bộ-dữ-liệu-nsl-kdd">3.1 Giới thiệu bộ dữ liệu NSL-KDD</h2><p>Bộ dữ liệu NSL-KDD khá nổi tiếng, được cải thiện từ bộ dữ liệu KDD’99. Dữ liệu này là về những thông tin mạng được thu thập bởi các nhà nghiên cứu, dữ liệu được chia thành nhiều nhãn, nhãn <code class="language-plaintext highlighter-rouge">normal</code> là thông tin gói tin bình thường từ người dùng bình thường và các nhãn khác như của các phương thức tấn công như <code class="language-plaintext highlighter-rouge">neptune</code>, <code class="language-plaintext highlighter-rouge">warezclient</code>, <code class="language-plaintext highlighter-rouge">ipsweep</code>, <code class="language-plaintext highlighter-rouge">portsweep</code>, v.v là của những người dùng có ý đồ xấu, gọi là hacker. Nhưng chúng ta sẽ coi tất cả phương thức tấn công như nhãn <code class="language-plaintext highlighter-rouge">abnormal</code> cho gọn. Bạn đọc có thể xem thêm chi tiết về bộ dữ liệu ở <a href="https://www.unb.ca/cic/datasets/nsl.html" target="_blank">đây</a></p><p><a name="-hien-thuc"></a></p><h2 id="32-hiện-thực">3.2 Hiện thực</h2><p>Bài toán sẽ được hiện thực bằng ngôn ngữ lập trình Python, kết hợp thêm thư viện Tensorflow để xây dựng mô hình Autoencoder.</p><p>Trước tiên ta sẽ đọc dữ liệu lên, bao gồm cả dữ liệu huấn luyện từ <code class="language-plaintext highlighter-rouge">KDDTrain+.txt</code> và dữ liệu kiểm thử <code class="language-plaintext highlighter-rouge">KDDTest+.txt</code>, đây là hai tập dữ liệu đầy đủ nhất, các tập dữ liệu còn lại được trích ra từ hai tập này.</p><p>Các thư viện được sử dụng trong hiện thực:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="n">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">confusion_matrix</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">OneHotEncoder</span><span class="p">,</span> <span class="n">MinMaxScaler</span>
</pre></table></code></div></div><p>Đọc dữ liệu lên bằng <code class="language-plaintext highlighter-rouge">pandas</code>.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">train</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'NSL-KDD-Dataset/KDDTrain+.txt'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'NSL-KDD-Dataset/KDDTest+.txt'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></table></code></div></div><p>Nói sơ qua về tập dữ liệu thì chúng ta có 43 cột, bao gồm các kiểu dữ liệu số và chữ. Cột dữ liệu cuối cùng là cột <code class="language-plaintext highlighter-rouge">difficulty</code>, theo link ở trên phần 3.1, nó không có tác dụng mấy trong việc xác định bất thường, nên ta sẽ bỏ đi. Cột dữ liệu kế cuối, có chỉ số là 41 là cột label của dữ liệu, bao gồm <code class="language-plaintext highlighter-rouge">normal</code> và các phương thức tấn công khác, mà ta lại muốn chuyển các phương thức tấn công thành <code class="language-plaintext highlighter-rouge">abnormal</code>, nên cuối cùng cột này sẽ chỉ có 2 giá trị duy nhất: <code class="language-plaintext highlighter-rouge">normal</code> và <code class="language-plaintext highlighter-rouge">abnormal</code>. Ngoài ra các cột dữ liệu chữ khác cũng cần được chuyển sang dạng OneHot, nghĩa là các giá trị chữ sẽ được chuyển thành một vector có độ dài bằng số lượng giá trị chữ duy nhất, sẽ điền giá trị 1 vào nếu phần tử tương ứng xuất hiện, ngược lại là 0, bạn đọc có thể tìm hiểu về OneHot ở <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" target="_blank">đây</a>. Các cột dữ liệu số không có khoảng giống nhau, như thế sẽ khiến cho mô hình hội tụ chậm hơn, nên ta cũng cần scale về $[0, 1]$ để tiện cho hàm activation <code class="language-plaintext highlighter-rouge">sigmoid</code> được sử dụng trong mô hình Autoencoder về sau.</p><p>Ta sẽ định nghĩa hai lớp dùng cho việc mã hóa OneHot và scale dữ liệu:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">encoder</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">handle_unknown</span><span class="o">=</span><span class="s">'ignore'</span><span class="p">)</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
</pre></table></code></div></div><p>Và định nghĩa một hàm để xử lý dữ liệu, dùng cho cả tập huấn luyện và kiểm thử đọc ở trên.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">is_fit</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
  <span class="c1"># chuyển normal thành 1 và các lớp khác thành 0
</span>  <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="mi">41</span><span class="p">]</span> <span class="o">==</span> <span class="s">'normal'</span><span class="p">,</span> <span class="s">'normal'</span><span class="p">,</span> <span class="s">'abnormal'</span><span class="p">)</span>

  <span class="c1"># loại bỏ cột dữ liệu không cần thiết
</span>  <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">([</span><span class="mi">41</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

  <span class="c1"># chia dữ liệu ra số, chữ để tiện xử lý
</span>  <span class="n">numerical_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="s">'object'</span><span class="p">).</span><span class="n">values</span>
  <span class="n">categorical_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s">'object'</span><span class="p">).</span><span class="n">values</span>

  <span class="c1"># chỉ fit với dữ liệu train
</span>  <span class="k">if</span> <span class="n">is_fit</span><span class="p">:</span>
    <span class="n">encoder</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">categorical_data</span><span class="p">)</span>

  <span class="c1"># chuyển từ dữ liệu chữ sang onehot
</span>  <span class="n">categorical_data</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">categorical_data</span><span class="p">).</span><span class="n">toarray</span><span class="p">()</span>

  <span class="c1"># nối dữ liệu số và onehot lại
</span>  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">numerical_data</span><span class="p">,</span> <span class="n">categorical_data</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

  <span class="c1"># chỉ fit với dữ liệu train
</span>  <span class="k">if</span> <span class="n">is_fit</span><span class="p">:</span>
    <span class="n">scaler</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  
  <span class="c1"># dữ liệu chuẩn hóa về dạng [0, 1]
</span>  <span class="n">data</span> <span class="o">=</span> <span class="n">scaler</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  
  <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
</pre></table></code></div></div><p>Sau đó đi xử lý cho hai tập. Một lưu ý nhỏ ở đây là ta cần cả hai tập huấn luyện và kiểm thử sau khi xử lý phải có số cột giống nhau, scale dữ liệu cũng sẽ giống nhau. Nên ta chỉ cần fit dữ liệu huấn luyện vào <code class="language-plaintext highlighter-rouge">encoder</code> và <code class="language-plaintext highlighter-rouge">scaler</code>, tập huấn luyện sẽ chỉ dùng lại dữ liệu đã fit, nên cả hai tập dữ liệu sẽ có số lượng cột giống nhau sau khi xử lý.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1"># xử lý dữ liệu
</span><span class="n">train</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</pre></table></code></div></div><p>Dữ liệu sau khi xử lý sẽ có cùng số lượng cột.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">train</span><span class="p">[</span><span class="s">'data'</span><span class="p">].</span><span class="n">shape</span><span class="p">,</span> <span class="n">test</span><span class="p">[</span><span class="s">'data'</span><span class="p">].</span><span class="n">shape</span>
</pre></table></code></div></div><pre><code class="language-plain">((125973, 146), (22544, 146))
</code></pre><p>Tiếp theo ta sẽ định nghĩa kiến trúc của Autoencoder. Lớp encoder sẽ có các lớp lần lượt là 64 -&gt; 32 -&gt; 16 -&gt; <strong>8</strong>. Lớp decoder sẽ có kích cỡ là 16 -&gt; 32 -&gt; 64 -&gt; <strong>146</strong>. Ở đây, 8 là lớp code, là lớp nhỏ nhất, đại diện cho thông tin quan trọng nhất đã được mã hóa, 146 là kích cỡ dữ liệu đầu vào, do ta muốn kích cỡ đầu ra phải giống hệt đầu vào. Ngoài lớp cuối cùng dùng hàm kích hoạt <code class="language-plaintext highlighter-rouge">sigmoid</code> để tạo dữ liệu về scale $[0, 1]$, thì các lớp còn lại sẽ dùng hàm kích hoạt <code class="language-plaintext highlighter-rouge">tanh</code>. Dưới đây mô tả lớp <code class="language-plaintext highlighter-rouge">Autoencoder</code> được thiết kế. Ngoài ra, ta sẽ tạo thêm hàm <code class="language-plaintext highlighter-rouge">get_construction_error</code> để tính lỗi tái tạo, hàm <code class="language-plaintext highlighter-rouge">predict_class</code> sẽ đi dự đoán ra lớp <code class="language-plaintext highlighter-rouge">normal</code> hay <code class="language-plaintext highlighter-rouge">abnormal</code> cụ thể.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Autoencoder</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Autoencoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">Sequential</span><span class="p">([</span>
      <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">),</span>
      <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">),</span>
      <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">),</span>
      <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">)</span>
    <span class="p">])</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">Sequential</span><span class="p">([</span>
      <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">),</span>
      <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">),</span>
      <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">),</span>
      <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'sigmoid'</span><span class="p">),</span>
    <span class="p">])</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>

  <span class="k">def</span> <span class="nf">get_reconstruction_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">keras</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">predict_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="n">reconstruction_error</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_reconstruction_error</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">reconstruction_error</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">,</span> <span class="s">'normal'</span><span class="p">,</span> <span class="s">'abnormal'</span><span class="p">)</span>
</pre></table></code></div></div><p>Ta sẽ đem chia các tập dữ liệu ra để tiện cho quá trình huấn luyện và kiểm thử.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1"># chia dữ liệu
</span><span class="n">train_normal</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="s">'data'</span><span class="p">][</span><span class="n">train</span><span class="p">[</span><span class="s">'label'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'normal'</span><span class="p">]</span>
<span class="n">train_abnormal</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="s">'data'</span><span class="p">][</span><span class="n">train</span><span class="p">[</span><span class="s">'label'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'abnormal'</span><span class="p">]</span>

<span class="n">test_normal</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="s">'data'</span><span class="p">][</span><span class="n">test</span><span class="p">[</span><span class="s">'label'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'normal'</span><span class="p">]</span>
<span class="n">test_abnormal</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="s">'data'</span><span class="p">][</span><span class="n">test</span><span class="p">[</span><span class="s">'label'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'abnormal'</span><span class="p">]</span>
</pre></table></code></div></div><p>Ta định nghĩa <code class="language-plaintext highlighter-rouge">optimizer</code> và <code class="language-plaintext highlighter-rouge">loss function</code> cho mô hình <code class="language-plaintext highlighter-rouge">Autoencoder</code> trên, optimizer có thể sử dụng là <code class="language-plaintext highlighter-rouge">Adam</code>, một dạng của Gradient-Descent, loss function có thể sử dụng là Mean Square Error, đo lường sự sai khác của dữ liệu số.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">model</span> <span class="o">=</span> <span class="n">Autoencoder</span><span class="p">(</span><span class="n">train_normal</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="n">Adam</span><span class="p">()</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="n">MeanSquaredError</span><span class="p">()</span>
<span class="n">model</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">loss_fn</span><span class="p">)</span>
</pre></table></code></div></div><p>Đem huấn luyện mô hình với <code class="language-plaintext highlighter-rouge">batch size</code> là 64 và số lượng lần lặp <code class="language-plaintext highlighter-rouge">epochs</code> là 100. Các bạn có thể dùng runtime GPU của Google Colab để tăng tốc quá trình huấn luyện.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">model</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_normal</span><span class="p">,</span> <span class="n">train_normal</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></table></code></div></div><p>Sau khi huấn luyện, ta sẽ mong muốn tính độ lỗi tái tạo của tập dữ liệu huấn luyện và tập kiểm thử để xem phân phối lỗi như thế nào.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1"># tính độ lỗi tái tạo cho tất cả các tập dữ liệu
</span>
<span class="n">train_normal_re</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">get_reconstruction_error</span><span class="p">(</span><span class="n">train_normal</span><span class="p">)</span>
<span class="n">train_abnormal_re</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">get_reconstruction_error</span><span class="p">(</span><span class="n">train_abnormal</span><span class="p">)</span>

<span class="n">test_normal_re</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">get_reconstruction_error</span><span class="p">(</span><span class="n">test_normal</span><span class="p">)</span>
<span class="n">test_abnormal_re</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">get_reconstruction_error</span><span class="p">(</span><span class="n">test_abnormal</span><span class="p">)</span>
</pre></table></code></div></div><p>Ta muốn có một ngưỡng $\theta_\alpha$ sao cho có thể phân chia tốt cả hai tập lỗi này. $\alpha$ tôi chọn trong bài là $0.5$, nhưng các bạn có thể tùy chỉnh theo dữ liệu của các bạn.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1"># tìm ngưỡng alpha từ tập train
</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">train_normal_re</span><span class="p">,</span> <span class="n">train_abnormal_re</span><span class="p">]).</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="n">alpha</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Ngưỡng vừa tìm được từ tập train:'</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
</pre></table></code></div></div><pre><code class="language-plain">Ngưỡng vừa tìm được từ tập train: 0.012324278242886066
</code></pre><p>Vẽ dữ liệu lên sẽ trông như thế này (hình 3 và 4). Độ lỗi <code class="language-plaintext highlighter-rouge">normal</code> bị lọt thỏm ở khoảng $0$, nghĩa là về cơ bản tái tạo giống hệt như ban đầu, còn độ lỗi <code class="language-plaintext highlighter-rouge">abnormal</code> khá là cao và phân phối rộng. Chỉ cần nhìn vào là ta đã biết được dữ liệu đó là thuộc lớp nào, điểm ngưỡng <code class="language-plaintext highlighter-rouge">threshold</code> sẽ giúp ta làm điều đó một cách chính xác hơn.</p><p> <img data-proofer-ignore data-src="/assets/autoencoder/hist_train.png" alt="hist_train" /> <em>Hình 3: Histogram phân phối lỗi của tập huấn luyện</em></p><p> <img data-proofer-ignore data-src="/assets/autoencoder/hist_test.png" alt="hist_test" /> <em>Hình 4: Histogram phân phối lỗi của tập kiểm thử</em></p><p>Độ chính xác trong việc phân loại hai tập dữ liệu khá cao: tập huấn luyện là <code class="language-plaintext highlighter-rouge">99%</code> và tập kiểm thử là <code class="language-plaintext highlighter-rouge">96%</code>.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">train_label_predict</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict_class</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="s">'data'</span><span class="p">],</span> <span class="n">threshold</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Độ chính xác tập huấn luyện'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">': '</span><span class="p">)</span>
<span class="n">accuracy_score</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="s">'label'</span><span class="p">],</span> <span class="n">train_label_predict</span><span class="p">)</span>
</pre></table></code></div></div><pre><code class="language-plain">Độ chính xác tập huấn luyện: 0.9978169925301453
</code></pre><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">test_label_predict</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict_class</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="s">'data'</span><span class="p">],</span> <span class="n">threshold</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Độ chính xác tập kiểm thử'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">': '</span><span class="p">)</span>
<span class="n">accuracy_score</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="s">'label'</span><span class="p">],</span> <span class="n">test_label_predict</span><span class="p">)</span>
</pre></table></code></div></div><pre><code class="language-plain">Độ chính xác tập kiểm thử: 0.9633161816891412
</code></pre><p>Dưới đây là confusion matrix của hai tập dữ liệu.</p><p> <img data-proofer-ignore data-src="/assets/autoencoder/cfx_train.png" alt="cfx_train" /> <em>Hình 5: Confusion matrix của tập huấn luyện</em></p><p> <img data-proofer-ignore data-src="/assets/autoencoder/cfx_test.png" alt="cfx_test" /> <em>Hình 6: Confusion matrix của tập kiểm thử</em></p><p>Toàn bộ code bạn đọc có thể lấy ở <a href="https://github.com/tuanio/autoencoder-anomaly-detection" target="_blank">đây</a>.</p><p><a name="-tong-ket"></a></p><h1 id="4-tổng-kết">4. Tổng kết</h1><p>Qua bài viết này, tôi đã giới thiệu về mô hình mạng neuron Autoencoder và ứng dụng của nó trong bài toán phát hiện bất thường trong an ninh mạng với bộ dữ liệu NSL-KDD. Kết quả sau khi thực nghiệm đạt độ chính xác cao. Bạn đọc có thể tìm hiểu thêm các dạng khác của Autoencoder như Sparse Autoencoder, Stack Autoencoder, Variational Autoencoder, v.v. Với mỗi dạng, sẽ có thể ứng dụng vào một bài toán nào đó khác nhau.</p><p><a name="-tham-khao"></a></p><h1 id="5-tham-khảo">5. Tham khảo</h1><p>[1] Ian Goodfellow, Yoshua Bengio, Aaron Courville. Deep Learning. 2016. MIT Press. <a href="http://www.deeplearningbook.org" target="_blank">http://www.deeplearningbook.org</a>.</p><p>[2] Wikipedia. Autoencoder. <a href="https://en.wikipedia.org/wiki/Autoencoder" target="_blank">https://en.wikipedia.org/wiki/Autoencoder</a>.</p><p>[3] Arden Dertat. Applied Deep Learning - Part 3: Autoencoders. 03/10/2017. <a href="https://towardsdatascience.com/applied-deep-learning-part-3-autoencoders-1c083af4d798" target="_blank">https://towardsdatascience.com/applied-deep-learning-part-3-autoencoders-1c083af4d798</a>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/knowledge/'>knowledge</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/machine-learning/" class="post-tag no-text-decoration" >machine learning</a> <a href="/tags/autoencoder/" class="post-tag no-text-decoration" >autoencoder</a> <a href="/tags/feedforward-neural-network/" class="post-tag no-text-decoration" >feedforward neural network</a> <a href="/tags/nsl-kdd-dataset/" class="post-tag no-text-decoration" >nsl-kdd dataset</a> <a href="/tags/unsupervised-learning/" class="post-tag no-text-decoration" >unsupervised learning</a> <a href="/tags/representation-learning/" class="post-tag no-text-decoration" >representation learning</a> <a href="/tags/anomaly-detection/" class="post-tag no-text-decoration" >anomaly detection</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Autoencoder và bài toán phát hiện bất thường trong an ninh mạng - tuanio&url=https://tuanio.github.io//posts/autoencoder/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Autoencoder và bài toán phát hiện bất thường trong an ninh mạng - tuanio&u=https://tuanio.github.io//posts/autoencoder/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Autoencoder và bài toán phát hiện bất thường trong an ninh mạng - tuanio&url=https://tuanio.github.io//posts/autoencoder/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/autorec/">AutoRec: Autoencoder dành cho Collaborative Filtering</a><li><a href="/posts/source-nlp/">Nguồn tài liệu để học NLP</a><li><a href="/posts/markov-chain-va-bai-toan-sang-nay-an-gi/">Markov Chain và bài toán 'Sáng nay ăn gì'</a><li><a href="/posts/minh-da-hoc-duoc-ghi-trong-nam-nay/">Mình đã học được gì trong năm nay?</a><li><a href="/posts/hidden-markov-model-and-sentiment-analysis/">Mô hình Markov ẩn và bài toán phân tích cảm xúc văn bản</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/machine-learning/">machine learning</a> <a class="post-tag" href="/tags/autoencoder/">autoencoder</a> <a class="post-tag" href="/tags/feedforward-neural-network/">feedforward neural network</a> <a class="post-tag" href="/tags/markov-process/">markov process</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/probability/">probability</a> <a class="post-tag" href="/tags/supervised-learning/">supervised learning</a> <a class="post-tag" href="/tags/alexnet/">alexnet</a> <a class="post-tag" href="/tags/anomaly-detection/">anomaly detection</a> <a class="post-tag" href="/tags/audio-classification/">audio classification</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/elm/"><div class="card-body"> <span class="timeago small" >Jan 10<i class="unloaded">2022-01-10T21:07:00+07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Extreme Learning Machine: Thuật toán học nhanh cho mạng neuron truyền thẳng một lớp ẩn</h3><div class="text-muted small"><p> Nội dung 1. Mạng neuron truyền thẳng một lớp ẩn 1.1 Định nghĩa 1.2 Bài toán học tham số 2. Thuật toán Extreme Learning Machine 3. Thực nghiệm thuật toán Extreme Lear...</p></div></div></a></div><div class="card"> <a href="/posts/autorec/"><div class="card-body"> <span class="timeago small" >Aug 5<i class="unloaded">2022-08-05T01:07:00+07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AutoRec: Autoencoder dành cho Collaborative Filtering</h3><div class="text-muted small"><p> Nội dung 1. Hệ thống khuyến nghị và phương pháp Lọc cộng tác 2. Kiến trúc AutoRec 3. Thực nghiệm với bộ dữ liệu MovieLens 3.1 Chuẩn bị dữ liệu 3.2 Thiết kế mô hình ...</p></div></div></a></div><div class="card"> <a href="/posts/source-nlp/"><div class="card-body"> <span class="timeago small" >Dec 23, 2021<i class="unloaded">2021-12-23T15:11:00+07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Nguồn tài liệu để học NLP</h3><div class="text-muted small"><p> Bài viết này mang tính chất lưu trữ và chia sẻ. Những nguồn khi mới bắt đầu How to get started in nlp - medium Dữ liệu nlp-datasets - github Sách Deep Learning for NLP and Speech R...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/elm/" class="btn btn-outline-primary" prompt="Older"><p>Extreme Learning Machine: Thuật toán học nhanh cho mạng neuron truyền thẳng một lớp ẩn</p></a> <a href="/posts/audio-classification/" class="btn btn-outline-primary" prompt="Newer"><p>Bài toán Audio Classification</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/tuanio">Nguyễn Văn Anh Tuấn</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/machine-learning/">machine learning</a> <a class="post-tag" href="/tags/autoencoder/">autoencoder</a> <a class="post-tag" href="/tags/feedforward-neural-network/">feedforward neural network</a> <a class="post-tag" href="/tags/markov-process/">markov process</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/probability/">probability</a> <a class="post-tag" href="/tags/supervised-learning/">supervised learning</a> <a class="post-tag" href="/tags/alexnet/">alexnet</a> <a class="post-tag" href="/tags/anomaly-detection/">anomaly detection</a> <a class="post-tag" href="/tags/audio-classification/">audio classification</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-ZJYTV5L278"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-ZJYTV5L278'); }); </script>
